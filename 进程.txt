一般来说，不同操作系统的 PCB 所包含的内容会有些差异，但通常应包括如下内容： 
（1）进程标识符。每个进程都必须有惟一的标识符，以区别于系统内部的其他进程。
 在进程创建时，由系统为进程分配惟一的进程标识符。 
（2）进程当前状态。说明进程的当前状态，以作为进程调度程序分配 CPU 的依据。 
（3）进程队列指针。用于记录 PCB 队列中下一个 PCB 的地址。为了查找方便，系统中 的
 PCB 可能组织成多个队列，如就绪队列、阻塞队列等。 
（4）程序和数据地址。指出进程的程序和数据所在的内（外）存地址。 
（5）进程优先级。优先级用于描述进程使用 CPU 的紧迫程度，是进程调度的一个依据。 优先级高的进程通常可优先获得 CPU。
（6）CPU 现场保护区。当进程因某种原因释放 CPU 时，要将此时的 CPU 现场信息（如 指令计数器、状态寄存器、通用寄存器等）保存在该区域中，以便进程重新获得 CPU 时 能恢复原来的 CPU 现场信息而继续执行。 
（7）通信信息。记录进程在执行过程中与其他进程所发生的信息交换情况。 
（8）家族关系。指明本进程的父进程、子进程等家族关系信息（如本进程的子进程与 父进程的标识符）。 
（9）占有资源清单。列出进程所需资源及当前已获得的资源。 

----------------------------------
1.pid                            |
2.指针                           |
3.外存中数据地址                 |
4.状态信息                       |
5.优先级                         |
6.CPU现场信息 PC 寄存器等等      |
7.家族信息                       |
8.通信信息                       |
9.占有资源清单                   |
----------------------------------

进入区
临界区 进程中访问临界资源的那段代码
退出区 
剩余区

线程实现方式
用户级线程 对用户不透明 对操作系统透明 
内核级线程 线程管理有操作系统内核完成，在和心态完成 

多对一模型 不需要切换核心态，线程管理开销比较小，
由于内核级线程才是处理机分配的单位，所以一个用户及线程阻塞，则整个进程阻塞

一对一模型 纯粹内核级线程 如果一个阻塞，其他也可以执行，并发性很强，对多核处理机支持很好 开销比较大

多对多模型 n->m n>m 
----------------------------------------------------------------------------------------------------
哲学家问题：
两个哲学家之间的筷子互斥访问，每个哲学家需要两个临界资源才能吃饭，避免死锁
设置互斥信号量数组 semaphore chopstick[5]={1,1,1,1,1}
哲学家编号 0 1 2 3 4 ，筷子编号 0 1 2 3 4 每个哲学家左边的都是自己编号的筷子，
右面的筷子可以用（哲学家编号+1）%5实现 
所以可以编写代码：
pi(){
		while(1)
		{
			P(chopstick[i]);
			p(chopstick[(i+1)%5]);
			//eating
			v(chopstick[i]);
			v(chopstick[(i+1)%5]);
		}
}
会出现循环等待...产生死锁 
1.可以允许四个哲学家同时进餐 这样总有一个哲学家有两根筷子 就不会产生死锁
2.可以先让相邻的两个哲学家争抢中间的那根筷子（ 奇数偶数 ）
3.可以再设置一个mutex，也就是当一个哲学家开始拿筷子，那么其他的哲学家就不能跟他强筷子，但是并行性低
semaphore mutex=1;
pi(){
		while(1)
		{
			P(mutex);
			P(chopstick[i]);
			p(chopstick[(i+1)%5]);
			v(mutex);
			//eating
			v(chopstick[i]);
			v(chopstick[(i+1)%5]);
		}
}
问题是：只能保证哲学家拿筷子是互斥的，但是即便旁边有筷子，也不行 
-----------------------------------------------------------------------------------------------------
读者写者问题
1.两个reader可以同时读
2.读写进程不能同时访问临界区
3.两个写进程都不能同时访问临界区
（写进程和任何进程都不能同时访问文件）

写进程 
读进程
1.写进程与其他所有进程都要互斥
2.读进程与读进程不互斥
semaphore rw = 1;//是否有进程在访问文件
读者与读者之间不能同时访问了...
解决方法 第一个Reader进程 P(rw) 上锁 第二个进程来的时候，如果是Reader，那么
跳过p(rw)的过程。
semaphore rw = 1; //信号量 
int count =0; //记录多少个读进程在访问
Writer()
{
	while(true)
	{
		p(rw);
		//..writer
		v(rw);
	}
}
int mutex =1;
Reader()
{
	while(true)
	{
		p(mutex);
		if(count==0)   /*有个问题在于，有可能第一个R进程进入if之后还没来得及count++就切换了，这样第二个进程也会被卡住*/
		p(rw);         /*检查和赋值不是一气呵成的 所以使用互斥变量来实现一气呵成 */
		count++;
		v(mutex);
		//..reading
		P(mutex);
		count--;
		if(0==count)
		V(rw);
		V(mutex);
	}
}
//一个问题，如果有源源不断的读进程来，那么写进程会发生饥饿甚至是饿死
//这里面默认了读进程优先的情况 
读写公平法 FCFS
设置三个信号量 
semaphore rw=1;
semaphore mutex=1;
semaphore w=1;
Writer()
{
	while(true)
	{
		P(w);
		P(rw);
		//write..
		V(rw);
		V(w);
	}
}

Reader()
{
	while(true)
	{
		P(w);
		P(mutex);
		if(0==count)
			P(rw);
		count++;
		V(mutex);
		V(w);
		//..reading
		P(mutex);
		count--;
		if(0==count)
		V(rw);
		V(mutex);
	
	}
}
-----------------------------------------------------------------------------------------------------
吸烟者进程 
三个抽烟者和一个供应者
抽烟者要卷烟+抽烟 卷烟需要三种材料 烟草 纸 水
三个抽烟者 第一个有烟草 第二个有纸 第三个有 水 都缺少另外两种
供应者放到桌子上 洗完之后通知供应者 

桌子看成：容量为1 ，初始为空   互斥 
桌子上有组合1 1取走 有组合2 2取走 有组合3 3取走 同步
发出完成信号之后 才放材料 同步  前 V 后 P
semaphore offer1=0;
semaphore offer2=0;
semaphore offer3=0;
semaphore finish=0;
int i=0;//用来轮流抽烟
provider()
{
	while(true){
		if(i==0)
		{
			//将第一组放在桌上
			V(offer1);  //通知等待的吸烟者可以来取材料了，这个是同步
		}
		else if(i==1)
		{
			//将第二组放在桌上
			V(offer2);//同步
		}
		else if(i==2)
		{
			//将第三组放在桌上
			V(offer3);//同步
		}
		i=(i+1)%3;
		P(fiish);//等待吸烟者完成吸烟的工作，这个是同步
	}
}

smoker1()
{
	while(true)
	{
		P(offer1);//先等待provider的v操作 同步
		拿走组合1 ，卷成烟卷 ，吸烟
		V(finish);
	}

}

smoker2()
{
	while(true)
	{
		P(offer2);//先等待provider的v操作
		拿走组合2 ，卷成烟卷 ，吸烟
		V(finish);
	}

}

smoker3()
{
	while(true)
	{
		P(offer3);//先等待provider的v操作
		拿走组合3 ，卷成烟卷 ，吸烟
		V(finish);
	}
}
/*发现同一时刻只有一个进程访问桌子，所以不需要互斥的桌子信号量*/
--------------------------------------------------------------------------------------------d
多生产者/消费者问题
互斥关系 盘子是互斥的 
同步关系 母亲儿子
		 父亲女儿
		 盘子为空
		 
//semaphore mutex=1;
semaphore apple=0;
semaphore orange=0;
semaphore plate=1;//盘子里面可以放多少个水果 

dad()
{
	while(true)
	{
		p(plate);
		//放入苹果
		v(apple);
	}
}

mother()
{
	while(true)
	{
	P(plate);
	//放入橘子
	v(orange);
	}
}

son()
{
	while(true)
	{
		p(apple);
		//get apple
		V(plate);
	}
}

daughter()
{
	while(true)
	{	
		
		p(orange);
		V(plate);
	}
}
//原因是缓冲区的大小为1

		 







