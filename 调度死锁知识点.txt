进程调度
高级调度（作业调度）：将外存中的人物放入内存并且创建相关PCB
中级调度（内存调度）：内存吃紧的时候，将不用的PCB 交换swap到外存，不吃紧的时候调回
低级调度（进程调度）：选择一个最优的进程上处理机

低级调度的两种情况
1.进程主动放弃处理机
	运行结束
	运行出现异常
	IO中断
2.进程被动放弃处理机
	时间片到
	更高优先级进程到了
	更紧急的事物抢占

进程调度方式
1.抢占式调度：只有抛出异常，正常结束，IO等待的时候才能切换 
2.非抢占式调度:当时间片结束，有更高权限的程序到来，或者更紧急的事物到来的时候切花

切换的一般步骤：
1.对现场保存
2.恢复换入程序的信息

保存的数据有：PC程序计数器，状态位，寄存器信息，现场信息等等

衡量调度算法的指标
1.CPU利用率 = CPU忙碌时间/总时间
2.cpu吞吐量（单位时间cpu处理的进程数量）= 处理进程总量/时间
3.周转时间 完成时间-提交时间 也就是作业执行的总时间
4.平均周转时间=各个作业周转时间之和/作业数量
5.带权周转时间 = 周转时间/运行时间>1
6.平均带权周转时间 = 每个作业的周转时间/作业数量
7.等待时间（从作业提交到开始运行花的时间）= 周转时间-运行时间
8.平均等待时间 = 每个作业的等待时间/作业数量
9.	响应时间 从提出请求到首次相应的时间 

进程调度算法
1.FCFS先到先服务算法
进程没有优先级之分，到了就服务，并且是非抢占式算法，对于大进程非常的友好，但是对于小进程不友好

2.JSF算法 最短作业优先算法
抢占式算法，如果来了一个更小的进程，那么就暂停之前的作业，等这个作业执行完之后再继续
对大作业不友好，造成饥饿。（平均等待时间，平均周转时间更短）

3.高相应比优先算法
非抢占式算法 
相应比 = （ 等待时间 + 运行总时间 ）/ 运行总时间
对于大进程 等待时间越长相应比越高 
对于小进程 运行总时间越小相应比越高
算是一种这种的算法

4.Round-Robin时间片轮转
抢占式算法
时间片过大，退化为FCFS
时间片过小，切换是有开销的，开销过大
不会造成饥饿

5.优先级调度算法
	1.可抢占/可非抢占
	2.静态优先级/动态优先级
	3.系统进程优先级高于用户进程
	4.前台进程优先级高于后台进程
	5.IO进程优先级高于计算优先级
	
5.多级反馈队列
a.设置多级队列，最上面优先级最高
b.优先级高的队列时间片短
c.一个进程在较高队列执行之后会被放到更低一级队列，
直到最后一级队列，最后一级队列执行时间片轮转
d.只有上面优先级的队列运行结束之后才能运行下面队列，
最后一个队列执行的时候，如果有较高优先级的来，那么限制性较高优先级


死锁
区分 死锁（2个或2个以上进程）/死循环/饥饿
死锁发生的四个条件
1.互斥条件：也就是多个进程争夺一个临界资源
2.不可剥夺条件：资源是不能够呗剥夺的，必须一个进程用完之后才可以
3.请求与保持条件：也就是进程即持有一种临界资源，又需要其他进程正在占有的资源
4.循环等待条件：形成一种等待链 （循环等待是死锁的必要充分条件，但是如果一种资源只有一个，那么就是充要条件）

预防死锁
1.破坏互斥资源：spooling技术
2.破坏不可剥夺条件:（1）一旦程序得不到需要运行的资源就立刻放弃掉自己的所有资源
				   （2）一旦要发生死锁，系统按照优先级剥夺资源
3.破坏请求和等待条件
					静态分配资源，分配不到不运行
4.破坏循环等待条件
				  资源的获得需要先获得优先级小的再获取优先级大的


避免死锁

安全序列
		能找到安全序列，那么一定不发生死锁
		找不到安全序列，也不一定会发生死锁，只是有可能发生死锁
		
银行家算法
假设现在有n个进程m种资源，设置一个最大需求的n*m矩阵，记录当前最大的资源数量，设置一个n*m的allocation矩阵，表示已经分配的资源数量，设置一个n*m的need矩阵，记录还需要多少资源，并且设置available数组用来记录还有多少资源可用，设置request数组，记录请求的资源量，具体算法如下:
（1）当有request请求的时候，将request i[j]与need[i][j]比较，如果request i[j]>need[i][j]说明资源请求超出了预定需求，错误，如果小于，则进行第二步
(2)将request i[j]与available[i][j]进行比较，如果request大于说明系统暂时没有这个资源可用，要等待，如果小于则下一步
(3)虚拟分配空间available[i][j]-request i[j],allocation[i][j]+request i[j],need[i][j]-request[i][j]
(4)进行安全序列判定，即如果need矩阵里有小于available的行，那么就将其资源数组加到available，继续对比，直到所以资源回归位置，如果不能回归不给分配。

死锁检测
进程结点指向资源结点，表示请求的资源，资源节点指向进程节点，表示资源已经分配的个数。
如果资源分配图可以完全简化，那么就不会发生死锁
（检测：先找到一个不阻塞也不孤立的结点pi，去掉所有边后继续找，直到不能再消去，就是死锁进程 ）

解除死锁


解决方法
1.	资源剥夺
2.	撤销进程
3.	进程回退 设置还原点





