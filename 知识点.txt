程序编译链接执行的流程
编译.c->链接.o->运行.exe 
装入的三种方式
1.绝对装入
2.静态重定位(link)
3.动态重定位(exe)
链接方式
1.静态链接
2.动态链接

分区的保护：
1.上下界寄存器
2.基址寄存器，限长寄存器

内存空间的扩增
一.覆盖技术 固定区+覆盖区(内存)
对用户不透明
二.换出技术 交换区+文件区(磁盘) 
内存空间的分配和回收
连续内存分配
1.单一连续分配 内部碎片
2.固定分区分配 内部碎片
3.动态内存分配 外部碎片
分配算法->分配（两种情况 1.分区大了 2.分区正好等于）->回收（3情况1.前或后有空闲 2.只有自己空 3.全都空闲 ）
 算法：

First Fit 首次适应算法
Next Fit 临近适应算法
Best Fit最佳适应算法 对大进程友好
Worst Fit最坏适应算法 对大进程不友好


非连续内存分配
分页存储管理
与固定分区分配&动态分区分配最大的不同就是，分配可以不连续
内存 -- 页框\页帧
进程 -- 页

关键问题： 逻辑地址 ->物理地址
逻辑地址=页面地址+偏移量
页面地址 = 逻辑地址/页面大小 x位地址码的前n位
逻辑地址=逻辑地址%页面大小 x位地址码的后m位
例如 m位表示页内地址偏移量 那么页面大小就是 2^m
n位表示页面编号，那么一共有2^n个页面
例如 32位地址分为20位的页面编号 12位的页内地址
那么一共有2^20=1M个页面 每个页面有2^12=4K的大小
所以内存大小一共有2^32=4GB
页表
 每个进程分配一张页表，块号信息记录在页表里面，页号可以省，并且页块的大小是固定的
所以页表里可以只放页面的块号，并且页表的初始地址记录在PTR中，同时记录在其中的还有
页表长度，寻址之前先要将要找的页号与长度对比，如果大于则抛出异常，如果小于那么查询页表
页表项地址=PTR初始地址+页号*页表长度 
分页管理是一维的 只需要提供逻辑地址 

局部性原理：时间局部性 空间局部性

TLB快表，先查快表，没有查慢表

访问两次内存

两级页表
如果进程过大，那么对应的页表也会很大，为了解决这个问题，不将页表独立出来，而是也按照分页的方式
存到内存中，假设一个页面最大容量是4KB，那么对于40位的内存，页面大小是2^12=4k 也就是12位用来表示偏移地址
28位用来表示页面编号，也就是说有2^28个页面，那么也就是4B的页表项长度，那么一个页面可以存放10K个页表项，那么
2^28次方的页面对应的页表项可以存放在 8 10 10 12这样三级页表里面，其中最后一位代表偏移地址12位

访问三次内存，一维

分页管理，产生内部碎片，没有外部碎片

分段管理方式
1.可见性
分段对用户是可见的，也就是将程序进行一个分区
分页对用户是不可见的，由操作系统负责操作

2.规则
内存长度一部分代表段长度，一部分代表叶长度
比如|        16bits(段号)         |       16bits(段内地址)     |
这样分配的话 也就是可以有2^16=64K个段，每个段最长可以是2^16=64K个段，每个段最长可以是2^16=64k
同样的，物理地址=段基址+偏移量 一般分段管理是二维的，即要给出段名称|偏移量
物理地址=段基址+偏移量
段基址的计算方法:查询段表
段表与页表的不同：
				1.段表有两项，一个是段表长度（段的长度不是固定的），
				还有一个是段的基址(段长变化，不方便通过块号进行计算)。
				
				2.段表的段表项长度不同，比如32位分页页表长度只要3B，
				然而对于32位分段，段表除了要存储段基址还要存储长度
				所以段表长度就应该是 32位对应的32bits，以及段内长度
				16位，一共需要46bits 也就是6B这么长。

查段表的时候，段表寄存器存放段表的初始地址，以及长度
两次比较：
		1.比较段号和段表长度，如果长那么异常
		2.比较段内地址与段表项中的长度，如果长那么抛出异常
段表的优点：
		更容易实现数据的保护与共享
分页管理方式不容易实现保护是因为，多个段可能在同一个页面里面，这样一个页面只有一部分是需要保护的，
另一部分不需要保护（允许多个进程访问），这样就不如段式管理将整个空间都设置为临界资源来的方便

分段管理，由于可变长没有内部碎片，但是产生外部碎片

段页式管理方式
将内存分为段号+页号+页内地址
|        16bits(段号)           |   4bits(页号)  |     12bits(页内地址)    |
16bits 段号 也就是一共可以分2^16个段
4bits 段内页号 也就是一个段可以分多少个页 16个也
12bits 段内地址 也就是一个页面的长度 4KB长度=2^12B

一共要查两层表
1.第一层是段表，里面记录了该段对应的页表的地址和长度
2.第二次是页表，里面记录了该段对应的页面的块号

同样要进行两次比较
1.比较段寄存器中的段表长度与该段的编号，超出则抛出异常
2.比较段表中的页表长度与页对应的页表号，超出则抛出异常

段页管理也是二维的！

虚拟内存:
传统内存管理:
1.一次性
2.驻留性
与之对应的虚拟内粗性质
1.一致性<-多次性
2.驻留性<-交换性
3.虚拟性

虚拟内存（最大）容量 CPU支持寻址的最大容量，比如32bits Processor 对应2^32=4GB内存 
		 64bits Processor 对应2^64B
虚拟内存（真实）容量 min(所有硬件内存总和，cpu最大寻容量)

请求调页/段&请求调页/段算法

分页存储管理方式虽然解决了内存中的碎片问题，但它要求将作业的所有页面一次调 
入内存。当内存可用空间不足或作业太大时，就会限制一些作业进入内存运行。
为此提出 了请求分页存储管理（也称请求页式存储管理）方法。 

请求分页管理方式
对比基本分页管理方式 
操作系统需要知道每个页面是否已经调入内存，如果没有调入则需要知道其在外存中的位置
当内存空间不足的时候，要实现页面置换，操作系统需要通过某些指标来决定到底换出哪个界面，有的页面没有被修改过，操作系统也就不需要再浪费时间将其写回外存，可以直接覆盖。

所以请求分页管理方式的页表分为：
内存块号 状态位 访问字段 修改位 外存地址
状态位记录了是否在内存中
访问字段记录可以访问的类型
修改位记录了是否修改，如果没修改就不用换出内存了
外存地址记录了在外存中的位置

内存替换算法：
缺页率=缺页发生的次数/访问的次数

OPT
找最远最不会使用的 （理想状态 无法实现）
FIFO
找最先进入的 (分配的页面越多，越慢)
LRU
找最近没使用的  往前找

时间轮转法
1.第一轮找访问位位0的，如果没有则置为0
2.第二轮访问找访问位位0 的 一定能找到
最多两轮

时间轮转法的改进法
从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，
对使用位不做任何修改。选择遇到的第一个帧(u=0, m=0)用于替换。
如果第1)步失败，则重新扫描，查找(u=0, m=1)的帧。选择遇到的第一个这样的帧用于替换。
在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0。
如果第2)步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0。重复第1步，
并且如果有必要，重复第2步。这样将可以找到供替换的帧。
最多四轮


抖动/颠簸
刚刚换出的界面马上又要换入内存 刚刚换出的内存马上又要换入内存 （进程频繁访问的页面数量高于可用物理块数量，系统大量时间处理幻如幻出）

工作集 某段时间里，进程实际访问页面的集合 （区分驻留集）窗口尺寸 工作集可能会小于窗口尺寸 
工作集小 可以分配更小的块 但是驻留级不能小于工作集

1 6 5 4 p0
1 0 0 2+0 9 8 4=1 9 8 6 p3
1 3 3 0+ 0 6 6 10=1 9 9 10 p4
0 2 4 10+2 7 5 0=2 9 9 10 p1
p2

p0->p3->p4->p1->p2


		
				





